
집합이란?

- 같은 타입의 서로 다른 값을 중복 없이 저장하고자 할 때 사용하는 집단 자료형이다

집합의 정의


// 초기값 적용
var genres: Set = ["클래식", "락", "발라드"]

// 초기값으로 텅 빈 배열을 사용
var g: Set<String> = []

// 초기값을 사용하지 않은 빈 집합을 정의
var genres = Set<String>()

// 집합에 아이템을 추가
genres.insert("클래식")
genres.insert("락")
genres.insert("발라드")

// 빈 집합인지 체크
if genres.isEmpty {
    // 집합이 비어있을때 실행
    print("집합이 비었습니다")
}else {
    // 집합이 비어있지 않을때 count를 사용하여 갯수를 새고 출력
    print("집합에는 현재\(genres.count)개의 아이템이 저장되어 있습니다")
}

집합 순회 탐색


// 집합을 정의
var genres: Set = ["클래식", "락", "발라드"]

// 집합을 순회 러리하면서 아이템을 출력
for g in genres {
    print("\(g)")
}
// 실행 결과 (순서는 랜덤) -> 이유는 집합에는 순서가 없다
클래식
락
발라드

집합의 동적 추가와 삭제

- 집합에 아이템을 추가할 때는 insert(_:) 메소드를 사용

- insert 메소드는 함께 전달된 인자값을 집합에 추가하지만, 같은 아이템이 저장되어 있으면 아무 처리도 하지 않는다

- 삭제할 때는 remove(_:) 메소드를 사용

- 삭제할 아이템 값이 있으면 삭제를 하고 삭제된 값을 반환하고 삭제할 아이템 값이 없으면 nil 반환

- removeAll()을 사용하면 집합 아이템 전체를 삭제할 수 있다


var genres: Set = ["클래식", "락", "발라드"]

genres.insert("재즈") // genres = {"재즈", "락", "클래식", "발라드"}
genres.insert("락") // genres = {"재즈", "락", "클래식", "발라드"} -> 락은 이미 있기때문에 반응x
genres.remove("락") // genres = {"재즈", "클래식", "발라드"}
genres.removeAll() // geners = {}

집합의 연산

- intersection(_:) -> 양쪽 집합에서 공통되는 아이템만 선택하여 새로운 집합을 만들어 주는 메소드 (교집합)

- symmetricDifference(_:) -> 양쪽 집합 중에서 어느 한쪽에만 있는 아이템을 선택하여 새로운 집합을 만들어 주는 메소드

- union(_:) -> 양쪽 집합에 있는 모든 아이템을 선택하여 새로운 집합을 만들어 주는 메소드 (합집합)

- subtract(_:) -> 한쪽 집합에 있는 모든 아이템에서 다른 쪽 집합에도 속하는 공통 아이템을 제외하는 메소드 (차집합)


subtract 메소드를 제외하면 나머지 메소드는 모두 양쪽 집합의 위치가 바뀌더라도 결과값은 동일하다

출처 입력


var oddDigits: Set = [1, 3, 5, 7, 9] // 홀수 집합
let evenDigits: Set = [0, 2, 4, 6, 8] // 짝수 집합
let primeDigits: Set = [2, 3, 5, 7] // 소수 집합

// 홀수 집합과 짝수 집합의 교집합
oddDigits.intersection(evenDigits).sorted() // []

// 홀수 집합과 소수 집합의 다른 부분 구하기
oddDigits.symmetricDifference(primeDigits).sorted() // [1, 2, 9]

// 홀수 집합과 짝수 집합의 합집합
oddDigits.union(evenDigits).sorted() // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// 홀수 집합 (차집합) 소수 집합
// subtract는 새로 집합을 만드는것이 아니라 빼기를 당하는 집합에 바로 저장을 하기 때문에 oddDigits를 var 즉 변수로 둔 이유이다.
oddDigits.subtract(primeDigits) // 아무 값도 반환하지 않기 때문에 바로 sorted()를 사용할 수 없다
oddDigits.sorted() // [1, 9]

부분집합과 포함관계 판단 연산

- isSubset(of:) -> 주어진 집합의 값 전체가 특정 집합에 포함되는지를 판단하여 true, false를 반환. 수학적으로 보면 하나의 집합이 다른 집합의 부분집합인지 여부를 판단한다

- isSuperset(of:) -> 주어진 집합이 특정 집합의 모든 값을 포함하는지를 판단하여 true, false를 반환한다. isSubset(of:)와 반대 상황을 판단한다. 집합이 다른 집합의 상위집합 역할을 하는가에 대한 판단을 담당하는 메소드이다

- isStrictSubset(of:)와 isStrictSuperset(of:) -> 위 두 메소드처럼 주어진 집합이 특정 집합의 부분집합인지 아니면 상위집합인지를 판단하는 역할을 하지만 두 집합이 서로 같은 경우의 결과값이 다르게 반환된다. 위 두 메소드는 두 집합이 일치하면 true를 반환하지만 isStrictSubset(of:)와 isStrictSuperset(of:) 메소드는 true를 반환하지 않는다.

- isDisjoint(with:) -> 두 집합 사이 공통 값을 확인하여 아무런 공통 값이 없을 때 true, 공통 값이 하나라도 있으면 false 반환


let A: Set = [1, 3, 5, 7, 9]
let B: Set = [3, 5]
let C: Set = [3, 5]
let D: Set = [2, 4, 6]

B.isSubset(of: A) //true
A.isSuperset(of: B) // true
C.isStrictSubset(of: A) // true
C.isStrictSubset(of: B) // false
A.isDisjoint(with: D) // true

// 배열에서 중복된 값들을 걸러내고 싶을 때
var A = [4, 2, 5, 2, 4, 5 ,6]

// A를 집합으로 변경
let B = Set(A)

// 집합으로 변해서 중복이 제거된 집합 B를 배열로 다시 변경
A = Array(B) // [6, 2, 5, 4]

﻿
