
프로퍼티(Property)란?

- 클래스나 구조체에서 값을 제공한다

- 역할에 따라 저장 프로퍼티(Stored Property), 연산 프로퍼티(Computed Property)로 나뉘고 소속에 따라 인스턴스 프로퍼티(Instance Property), 타입 프로퍼티(Type Property)로 나뉜다

저장 프로퍼티

- 클래스 내에서 선언된 변수나 상수를 부르는 이름

- 입력된 값을 저장하거나 저장된 값을 제공하는 역할

- 상수 및 변수를 사용해서 정의 가능

- 클래스와 구조체에서는 사용이 가능하지만, 열거형에서는 사용할 수 없다

오류가 난 저장 프로퍼티 수정 방법


// 초기값을 할당해주지 않아서 오류가 난다
class User {
    var name: String
}


// 초기화 구문을 작성하고, 그 안에서 초기값을 할당해주는 방법
class User {
    var name: String

    init() {
        self.name = ""
    }
}

// 프로퍼티를 옵셔널 타입으로 바꿔 주기
class User {
    var name: String? 또는 var name:String!
}

// 애초에 프로퍼티에 초기값을 할당해주기
class User {
    var name: String = ""
}

지연 저장 프로퍼티

- 저장 프로퍼티 정의 앞에 lazy라는 키워드를 붙혀 사용

- 호출되기 전에는 선언만 된 상태로 대기, 실제로 호출되는 시점에서 초기화가 이루어지는 저장 프로퍼티


import UIKit

class OnCreate {
    init() {
        print("OnCreate!!")
    }
}

class LazyTest {

    var base = 0
    // 지연 저장 프로퍼티
    lazy var late = OnCreate()

    init() {
        print("Lazy Test")
    }
}

// late가 실행되지 않고 Lazy Test만 나온다
let lz = LazyTest()

// 이렇게 호출을 해주어야 OnCreate()가 실행되면서 OnCreate!!가 출력된다
lz.late

연산 프로퍼티

- 필요한 값을 제공한다는 점에서 저장 프로퍼티와 같지만, 실제 값을 저장했다가 반환하지는 않고 대신 다른 프로퍼티의 값을 연산 처리하여 간접적으로 값을 제공한다

- 변수만 사용해서 정의 가능

- 클래스, 구조체, 열거형 모두에서 사용 가능

연산 프로퍼티 사용 예


import Foundation

struct UserInfo {
    // 저장 프로퍼티: 태어난 연도
    var birth: Int!
    
    
    // 연산 프로퍼티: 올해가 몇년도인지 계산
    var thisYear: Int! {
        get {
            let df = DateFormatter()
            df.dateFormat = "yyyy"
            return Int(df.string(from: Date()))
        }
    }
        // 연산 프로퍼티: 올해 - 태어난 연도 + 1
        var age: Int {
            get {
                return (self.thisYear - self.birth) + 1
            }
        }
    }

let info = UserInfo(birth: 1980)
print(info.age)

프로퍼티 옵저버

- 특정 프로퍼티를 계속 관찰하고 있다가 프로퍼티의 값이 변경되면 이를 알아차리고 반응

- 프로퍼티의 값을 직접 변경하거나 시스템에 의해 자동으로 변경하는 경우에 상관없이 일단 프로퍼티의 값이 설정되면 무조건 호출

- 저장 프로퍼티에 값을 대입하는 구문이 수행되거나 연산 프로퍼티에서 set 구문이 실행되는 모든 경우에 호출

willSet - 프로퍼티의 값이 변경되기 직전에 호출되는 옵저버

didSet - 프로퍼티의 값이 변경된 직후에 호출되는 옵저버

willSet, didSet 사용법


// 대괄호 []에 둘러싸여서 표시되는 부분은 생략이 가능한 부분
// 실제로 대괄호 [] 표시 x
var <프로퍼티명>: <타입> [ = <초기값> ] {
    willSet [ (<인자명>) ] {
        <프로퍼티 값이 변경되기 전에 실행할 내용>
    }
}

var <프로퍼티명>: <타입> [ = <초기값> ] {
    didSet [ (<인자명>) ] {
        <프로퍼티 값이 변경된 후에 실행할 내용>
    }
}

// 항상 함께 구현하지 않아도 된다

저장 프로퍼티에 willSet과 didSet을 구현한 예


struct Job {
    var income: Int = 0 {
        willSet(newIncome) {
            print("이번 달 월급은 \(newIncome)원입니다.")
        }
        didSet {
            if income > oldValue {
                print("월급이 \(income - oldValue)원 증가하셨네요. 소득세가 상향조정될 예정입니다")
            } else {
                print("저런, 월급이 삭감되었군요. 그래도 소득세는 깍아드리지 않아요.")
            }
        }
    }
}

// 월급이 1000000원인 Job 인스턴스가 생성되어 job변수에 할당, 초기값 생성
var job = Job(income: 1000000)

// 월급 인상
job.income = 20000000

// 출력 화면
// 이번 달 월급은 20000000원입니다. -> willSet 구문에서 출력
// 월급이 19000000원 증가하셨네요. 소득세가 상향조정될 예정입니다 -> didSet 구문에서 출력

실행 순서: 프로퍼티의 값 변경 시작 -> willSet 구문 실행 -> 프로퍼티의 값 변경 -> didSet 구문 실행

인스턴스 프로퍼티

- 저장 프로퍼티나 연산 프로퍼티는 클래스 또는 구조체 인스턴스를 생성한 후 이 인스턴스를 통해서만 참조할 수 있는 프로퍼티였다. 이는 이들 프로퍼티가 인스턴스에 관련된 값을 저장하고 다루므로 인스턴스 프로퍼티라고 부른다

타입 프로퍼티

- 경우에 따라 인스턴스에 관련된 값이 아니라 클래스나 구조체, 또는 열거형과 같은 객체 자체에 관련된 값을 다루어야 할 때도 있는데, 이때는 인스턴스를 생성하지 않고 클래스나 구조체 자체에 값을 저장하게 되며 이를 타입 프로퍼티라고 한다

﻿
