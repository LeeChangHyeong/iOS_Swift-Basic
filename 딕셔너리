
딕셔너리란?

- 고유 키(Key)와 그에 대응하는 값(Value)을 연결하여 데이털르 저장하는 자료형


[키: 데이터, 키: 데이터]

주의점

- 하나의 키는 하나의 데이터에만 연결되어야 한다

- 하나의 딕셔너리에서 키는 중복될 수 없다. 중복해서 선언하면 아이템 추가가 아니라 수정이 이루어져 기존 키에 연결되 데이터가 제거된다

- 저장할 수 있는 데이터 타입에는 제한이 없지만, 하나의 딕셔너리에 저장하는 데이터 타입은 모두 일치해야 한다

- 딕셔너리 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for ~ in 구문을 이용한 순회 탐색 가능

딕셔너리의 정적 선언과 값의 정의


var capital = ["KR": "서울", "EN": "런던", "FR": "파리"]

// 딕셔너리의 참조
// key: KR, value: 서울
capital["KR"] // "서울"

// key: EN, value: 런던
capital["EN"] // "런던"

// key: FR, value: 파리
capital["FR"] // "파리"

딕셔너리의 선언과 초기화


Dictionary <키의 타입, 값의 타입>()

// 문자열 키와 정수 값으로 이루어진 딕셔너리
Dictionary<String, Int>()
[String : Int]()

// 문자열 키와 문자열 값으로 이루어진 딕셔너리
Dictionary<String, String>()
[String : String]()

// 선언과 동시에 초기화하기
var capital = Dictionary<String, String>()
var capital = [String : String]()

// 선언과 초기화 분리하기
var capital : Dictionary<String, String>
capital = Dictionary()
var capital : [String : String]
capital = [String : String]()

딕셔너리에 동적으로 아이템 추가와 삭제


var newCapital = [String : String]()
// []안에 키 값을 넣고 대입 연산자로 원하는 값을 할당한다
newCapital["JP"] = "도쿄"

// 딕셔너리도 배열에서처럼 아이템의 개수가 딕셔너리의 크기를 결정한다
newCapital.count // 1

// <딕셔너리 객체>.updateValue(<저장할 데이터>, forKey:<데이터를 참조및 저장하는 데 사용할 키>)
// "KR": "서울" 데이터가 추가되고 nil리턴
newCapital.updateValue("서울", forKey: "KR")

// "EN": "런던" 데이터가 추가되고 nil리턴
newCapital.updateValue("런던", forKey: "EN")

// "JP": "사포로" 데이터로 수정되고 "도쿄"리턴
newCapital.updateValue("사포로", forKey: "JP")

// 삭제를 알아보기 위해 삭제할 데이터 두개 추가
newCapital.updateValue("베이징", forKey: "CN")
newCapital.updateValue("파리 ", forKey: "FR")

삭제하는 방법은 두가지다. 키에 연결된 값이 직접 nil을 할당하는 방법과 명시적으로 removeValue(forKey:)를 사용하는 법
// nil 할당 삭제
newCapital["CN"] = nil

// 메소드 사용
newCapital.removeValue(forked: "FR")

딕셔너리의 순회 탐색


for row in newCapital {
    // 딕셔너리에서 꺼낸 키-값 한 쌍이 담긴 row 상수를 튜플로 받는다
    let (key, value) = row
    print("현재 데이터는 \(key) : \(value)입니다")
}

for (key, value) in newCapital {
    print("현재 데이터는 \(key) : \(value)입니다")
}

// 둘다 결과는
현재 데이터는 JP : 사포로입니다
현재 데이터는 EN : 런던 입니다
현재 데이터는 KR : 서울입니다

﻿
