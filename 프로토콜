
프로토콜이란(?)

- 클래스나 구조체가 어떤 기준을 만족하거나 또는 특수한 목적을 달성하기 위해 구현해야 하는 메소드와 프로퍼티의 목록

프로토콜의 정의


protocol <프로토콜명> {
    <구현해야 할 프로퍼티 명세1>
    <구현해야 할 프로퍼티 명세2>
    <구현해야 할 프로퍼티 명세3>
    ...
    <구현해야 할 메소드 명세1>
    <구현해야 할 메소드 명세2>
    <구현해야 할 메소드 명세3>
    ...
}

프로토콜 프로퍼티

- 프로토콜에 선언되는 프로퍼티에는 초기값을 할당할 수 없다

- 연산 프로퍼티인지 저장 프로퍼티인지도 구분하지 않는다


protocol SomePropertyProtocol {
    var name:String { get set }
    var description: String { get }
}

위 코드는 인스턴스 프로퍼티 두개를 SomePropertyProtocol 프로토콜에 선언하고 있다.

실제로 내용을 선언한 것이 아니라 이러이러한 종류의 프로퍼티가 선언될 것이라고 설명하는 의미이다.

읽기 전용으로 설정할 때는 get만, 읽고 쓰기가 모두 가능한 프로퍼티를 선언하고자 할 때는 get과 set을 모두 작성.


struct Member: SomePropertyProtocol {
    var name = "홍길동"
    var description: String {
    return "Name: \(self.name)"
  }
}

앞에서 정의한 SomePropertyProtocol 프로토콜을 구현한 구조체이다.

구현할 대상 프로토콜을 선언하고, 그에 맞는 프로퍼티 명세를 내부에서 구현하고 있다.

프로토콜에서 get set으로 선언된 name 프로퍼티는 저장 프로퍼티로,

읽기 전용으로 선언된 description 프로퍼티는 연산 프로퍼티로 구현하고 있는 것을 볼 수 있다.

프로토콜 메소드


protocol SomeMethodProtocol {
    func execute(cmd: String)
    func showPort(p: Int) -> String
}

SomeMethodProtocol은 두개의 인스턴스 메소드를 포함하고 있다.

두 메소드는 모두 매개변수가 정의되어 있지만, 모든 프로토콜에서 반드시 메소드에 매개변수를 정의해야 하는 것은 아니다.

메소드의 반환값 역시 선택 사항으로, 메소드의 성격에 맞게 생략하거나 작성하면 된다.


struct Service: SomeMethodProtocol {
    func execute(cmd: String) {
        if cmd == "strart" {
            print("실행합니다")
        }
    }

    func showPort(p: int) -> String {
        return "Port: \(p)"
    }
}

앞에서 정의한 SomeMethodProtocol 프로토콜을 구현하고 있는 구조체이다.

프로토콜에 선언된 메소드 중에서 일부를 구현하지 않고 누락하면 오류가 발생한다. 하지만 프로토콜에 정의되어 있지 않더라도 구현체에 임의로 메소드를 추가하는 것은 아무런 문제가 되지 않는다.

﻿
